# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/models.multi_slice_ptychography.ipynb.

# %% auto 0
__all__ = ['MultiSlicePtychographyModel']

# %% ../../nbs/models.multi_slice_ptychography.ipynb 1
from . import BaseModel
from ..operators.composite import exitwave_measurement, grid_sample_partial, bin_z
from ..operators.split import BatchCropVolume
from ..kernels import overlap_real_volume
from ..core import dtype_complex, dtype_real
from ..util.plot import plot, plotAbsAngle
import torch as th 

class MultiSlicePtychographyModel(BaseModel):
    def __init__(self,
                 object,
                 probe,
                 positions,
                 # start_end_model,
                 loss_function,
                 propagator,
                 bin_factor,
                 # intensity_scaling_factor
                 ):
        n_angles = 1
        
        self.object = object
        self.probe = [[probe]]
        self.positions = [positions]
        self.angles = th.zeros((3, n_angles), device=object.device)
        self.translations = [th.zeros((2, 1), device=object.device)] * n_angles
        self.start_end_model = [[[0, object.shape[0]], [0, object.shape[1]], [0, object.shape[2]]]] * n_angles
        self.loss_function = loss_function
        self.propagator = propagator
        self.bin_factor = bin_factor
        self.intensity_scaling_factor = 1
        NY, NZ, NX = self.object.shape # NVol, NY, NZ, NX
        # TODO make general
        Nnodes, K, MY, MX = probe.shape
        self.object_norm = th.zeros((NY, NZ, NX), device=self.object.device, dtype=dtype_real, requires_grad=False)
        self.probe_norm = th.zeros((Nnodes, K, MY, MX), device=self.object.device, dtype=dtype_real, requires_grad=False)
        self.NZ = NZ

        self.batch_crop_volume = BatchCropVolume()
        
    def scale_probe_gradient(self, probe):
        alpha = 0.9
        denom = th.sqrt(1e-16 + ((1 - alpha) * self.probe_norm) ** 2 + (alpha * th.max(self.probe_norm)) ** 2)
        # print('denom ', denom.max().item(), denom.min().item())
        denom = th.prod(denom, dim=0, keepdim=True)
        probe.grad /= denom

    
    def scale_object_gradient(self, object):
        alpha = 0.9
        denom = th.sqrt(1e-16 + ((1 - alpha) * self.object_norm) ** 2 + (alpha * th.max(self.object_norm)) ** 2)
        object.grad /= denom
        self.object_norm.fill_(0)

        
    def multislice_exitwave_multimode(self, object_patches, waves, pos, propagator):
        """
        Implements the multislice algorithm - no anti-aliasing masks
        :param object_patches:             NZ_bin x K x M1 x M2         complex
        :param object_patch_normalization: NZ_bin x K x M1 x M2         real
        :param waves:                      Nmodes x K x M1 x M2     complex
        :param propagator: f: (K x M1 x M2, Nmodes      x K x M1 x M2) -> Nmodes      x K x M1 x M2
        :return: exitwaves:                Nmodes x K x M1 x M2
        """
        for i in range(len(object_patches)):
            waves = object_patches[i].unsqueeze(0) * waves
            if object_patches.requires_grad:
                patch_norm = th.sum(th.abs(waves.clone().detach()) ** 2, 0)
                tmp = th.zeros_like(self.object_norm[:, i, :])
                overlap_real_volume(pos.data.to(th.int64), patch_norm.data, tmp.data)
                self.object_norm[:, i, :] = tmp
            waves = propagator(waves)
        return waves

    def object_model(self, V, probe, pos, angles, translation, bin_factor, start_end):
        """
        :param V: (NY, NZ, NX) complex
        :param probe: (Nmodes, K, MY, MX) complex
        :param pos: (K, 2) real
        :return: (NZ, K, MY, MX) complex
        """
        ##NX x NZ x NY -> NZ x K x M1 x M2
        T_patches = self.batch_crop_volume(V, probe, pos)
        return T_patches

    # object_patches, positions, probe, propagator, factor
    def measurement_model(self, object_patches, pos, probe, propagator, factor):
        """
        :param object_patches: (NZ, K, MY, MX) complex
        :param pos: (K, 2) real
        :param probe: (Nmodes, K, MY, MX) complex
        :param propagator: Callable
        :param factor: float
        :return: (K, MY, MX) real
        """
        if probe.requires_grad:
            # sum over positions
            self.probe_norm = th.sum(th.abs(object_patches.detach()) ** 2, 1, keepdim=True)

        # Nmodes x K x MY x MX
        phi = self.multislice_exitwave_multimode(object_patches, probe, pos, propagator)
        measurements = exitwave_measurement(phi)
        
        # K x MY x MX
        return measurements

    def __call__(self, object, probe, positions, angle=None, translation=None, bin_factor=None, start_end=None,
                 propagator=None, factor=1):
        # NZ x K x MY x MX
        NY, NZ, NX = object.shape
        _, _, MY, MX = probe.shape
        K, _ = positions.shape
        object_patches = self.object_model(object, probe, positions, angle, translation, bin_factor, start_end)
        measurements = self.measurement_model(object_patches, positions, probe, propagator, factor)
        return measurements
