# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/models.single_slice_ptychography.ipynb.

# %% auto 0
__all__ = ['SingleSlicePtychographyModel']

# %% ../../nbs/models.single_slice_ptychography.ipynb 1
from . import BaseModel
from ..operators.composite import exitwave_measurement, scale_reversible
from ..operators.split import split, BatchCrop
from ..core import dtype_complex, dtype_real
from ..kernels import overlap_intensity, overlap_intensity_no_subpix
from ..operators.basic import farfield_amplitude_multimode, farfield_amplitude_singlemode
import torch as th
from ..util.base import fftshift_checkerboard


class SingleSlicePtychographyModel(BaseModel):
    def __init__(self,
                 object,
                 probe,
                 positions,
                 loss_function):
        is_mixed_state = True  #probe.shape[0] > 1
        n_angles = 1

        self.object = object
        self.propagator = None
        self.probe = [[probe]]
        self.positions = [positions]

        self.angles = th.zeros((3, n_angles), device=object.device)
        self.translations = [th.zeros((2, 1), device=object.device)] * n_angles
        self.start_end_model = [[[0, object.shape[1]], [0, object.shape[2]]]] * n_angles
        self.loss_function = loss_function
        self.bin_factor = 1
        self.intensity_scaling_factor = 1

        self.fftshift_checkerboard = th.tensor(fftshift_checkerboard(probe.shape[-1], probe.shape[-2]),
                                               device=object.device).unsqueeze(0).unsqueeze(0)

        self.subpix_shift = False

        _, NY, NX = self.object.shape
        # TODO make general
        _, _, MY, MX = probe.shape
        # TODO make general
        K, _ = self.positions[0].shape
        self.object_norm = th.zeros(self.object.shape, device=self.object.device, dtype=dtype_real, requires_grad=False)
        self.probe_norm = th.zeros(self.probe[0][0].shape, device=self.object.device, dtype=dtype_real,
                                   requires_grad=False)
        if is_mixed_state:
            self.farfield_amplitude = farfield_amplitude_multimode
        else:
            self.farfield_amplitude = farfield_amplitude_singlemode

    def scale_probe_gradient(self, probe):
        alpha = 0.9
        denom = th.sqrt(1e-16 + ((1 - alpha) * self.probe_norm) ** 2 + (alpha * th.max(self.probe_norm)) ** 2)
        probe.grad /= denom
        # grad_max = th.max(th.abs(probe.grad)).item()
        # probe_max = th.max(th.abs(probe)).item()
        # print(f'grad_max: {grad_max}')
        # print(f'probe_max: {probe_max}')

    def scale_object_gradient(self, object):
        alpha = 0.9
        denom = th.sqrt(1e-16 + ((1 - alpha) * self.object_norm) ** 2 + (alpha * th.max(self.object_norm)) ** 2)
        object.grad /= denom
        self.object_norm.fill_(0)

    def measurement_model(self, object_patches, pos, probe, propagator, factor):
        """
        Single slice ptychography model for potential reconstruction.
        :param object_patches: potential, (1 x K x M1 x M2), complex
        :param pos: probe positions (K, 2) float
        :param probe: (Nmodes, K, MY, MX) complex
        :param factor: float, not important for this model
        :return: a_model, measured amplitudes (K, MY, MX) float
        """
        if self.subpix_shift:
            patch_norm = th.sum(th.abs(probe.detach()) ** 2, 0)
            raise RuntimeError('not Implemented')
        else:
            ps = probe.shape
            # MY x MX
            patch_norm = th.sum(th.abs(probe.detach()) ** 2, 0).squeeze()
            # calculate normalization for object gradient
            overlap_intensity_no_subpix(pos.data.to(th.int64), patch_norm.data, self.object_norm.data)
            # expand probe to K positions to keep dimension same as subpix_shifted probe
            probe = probe.expand((ps[0], pos.shape[0], ps[2], ps[3]))

        if probe.requires_grad:
            # sum over positions
            self.probe_norm = th.sum(th.abs(object_patches.detach()) ** 2, 1, keepdim=True)

        exit_wave = object_patches * probe
        a_model = self.farfield_amplitude(exit_wave * self.fftshift_checkerboard)
        return a_model

    def object_model(self, obj, probe, pos, angles, translation, bin_factor, start_end):
        """
        Single slice ptychography model 
        :param obj: potential, (1, NY, NX), real or complex
        :param pos: probe positions (K, 2) float
        :param angles: Any, not important for this model
        :param translation: Any, not important for this model
        :param bin_factor: Any, not important for this model
        :param start_end: Any, not important for this model
        :param propagator: Any, not important for this model
        :param M: 2D shape of probe
        :return: T_patches, measured amplitudes (1 x K x M1 x M2) complex
        """
        # T = th.exp(1j * V)
        T_patches = split(obj, probe, pos)  # out:  1 x K x M1 x M2
        return T_patches  #.unsqueeze(0).expand((2,*sh))

    def __call__(self, object, probe, positions, angle=None, translation=None, bin_factor=None, start_end=None,
                 propagator=None, intensity_scaling_factor=1):
        # NZ x K x MY x MX
        Nvol, NY, NX = object.shape
        _, _, MY, MX = probe.shape
        K, _ = positions.shape
        object_patches = self.object_model(object, probe, positions, angle, translation, bin_factor, start_end)
        measurements = self.measurement_model(object_patches, positions, probe, propagator, intensity_scaling_factor)
        return measurements
