# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/operators.basic.ipynb.

# %% auto 0
__all__ = ['scale_reversible', 'bin_z', 'complex_abs', 'farfield_amplitude_multimode', 'farfield_amplitude_singlemode',
           'fourier_coordinates_2D', 'Propagator', 'ComplexAbs', 'FourierExitwaveMeasurementSingleMode',
           'FourierExitwaveMeasurementMultiMode', 'BinObject', 'Bin', 'BatchCrop', 'ScaleReversible']

# %% ../../nbs/operators.basic.ipynb 2
from nbdev.showdoc import *
import torch as th
import torch.nn.functional as F
from ..kernels import split, overlap, overlap_real
from ..core import dtype_complex, dtype_real
import numpy as np

# %% ../../nbs/operators.basic.ipynb 3
from numpy.fft import fftfreq, fftshift
def fourier_coordinates_2D(N, dx=[1.0, 1.0], centered=True):
    qxx = fftfreq(N[1], dx[1])
    qyy = fftfreq(N[0], dx[0])
    if centered:
        qxx += 0.5 / N[1] / dx[1]
        qyy += 0.5 / N[0] / dx[0]
    qx, qy = np.meshgrid(qxx, qyy)
    q = np.array([qy, qx]).astype(np.float32)
    return q

class Propagator(th.nn.Module):

    def __init__(self, slice_thickness, wavelength, dx, shape, device='cpu'):
        super().__init__()
        q = th.as_tensor(fourier_coordinates_2D(shape, dx, False), device = device)
        q2 = th.linalg.norm(q, axis=0) ** 2
        self.prop = th.exp((-1j * np.pi * wavelength * slice_thickness) * q2)

    def forward(self, waves):
        """

        :param waves: Nmodes      x K x M1 x M2
        :return:      Nmodes      x K x M1 x M2
        """
        waves = th.fft.fft2(waves)
        waves *= self.prop
        waves = th.fft.ifft2(waves)
        return waves
    
class ComplexAbs(th.autograd.Function):
    '''Absolute value class for autograd'''

    @staticmethod
    def forward(ctx, tensor_in):
        """
        
        :param ctx: 
        :param tensor_in: Nmodes, K, MY, MX
        :return: 
        """
        output = th.abs(tensor_in)
        ctx.save_for_backward(tensor_in)
        return output

    @staticmethod
    def backward(ctx, grad_output):
        """
        
        :param ctx: 
        :param grad_output: 2, Nmodes, K, MY, MX
        :return: 
        """
        psi_old, = ctx.saved_tensors
        psi_updated = grad_output * th.sgn(psi_old)
        grad_tensor_in = psi_old - psi_updated
        # grad_tensor_in = -psi_updated
        return grad_tensor_in

class FourierExitwaveMeasurementSingleMode(th.autograd.Function):
    '''Absolute value class for autograd'''

    @staticmethod
    def forward(ctx, wave):
        """
        fourier_overlap = xp.fft.fft2(overlap)
        farfield_amplitudes = self._return_farfield_amplitudes(fourier_overlap)
        error = xp.sum(xp.abs(amplitudes - farfield_amplitudes) ** 2)

        farfield_amplitudes[farfield_amplitudes == 0.0] = np.inf
        amplitude_modification = amplitudes / farfield_amplitudes

        fourier_modified_overlap = amplitude_modification[:, None] * fourier_overlap
        modified_overlap = xp.fft.ifft2(fourier_modified_overlap)

        exit_waves = modified_overlap - overlap
        :param ctx: 
        :param tensor_in: Nmodes, K, MY, MX
        :return: wave
        """
        wave_fourier = th.fft.fft2(wave, norm='ortho')
        amplitude_fourier = th.abs(wave_fourier[0]) ** 2
        af = amplitude_fourier.detach()
        af[af == 0.0] = np.inf
        ctx.save_for_backward(af, wave_fourier, wave)
        return amplitude_fourier

    @staticmethod
    def backward(ctx, amplitudes_target):
        """
        
        :param ctx: 
        :param grad_output: 2, Nmodes, K, MY, MX
        :return: 
        """
        af, wave_fourier, wave = ctx.saved_tensors
        amplitude_modification = amplitudes_target / af
        
        fourier_modified_overlap = amplitude_modification[None] * wave_fourier
        modified_overlap = th.fft.ifft2(fourier_modified_overlap, norm='ortho')
        
        grad_tensor_in = wave - modified_overlap
        return grad_tensor_in
    
class FourierExitwaveMeasurementMultiMode(th.autograd.Function):
    '''Absolute value class for autograd'''

    @staticmethod
    def forward(ctx, wave):
        """
        fourier_overlap = xp.fft.fft2(overlap)
        farfield_amplitudes = self._return_farfield_amplitudes(fourier_overlap)
        error = xp.sum(xp.abs(amplitudes - farfield_amplitudes) ** 2)

        farfield_amplitudes[farfield_amplitudes == 0.0] = np.inf
        amplitude_modification = amplitudes / farfield_amplitudes

        fourier_modified_overlap = amplitude_modification[:, None] * fourier_overlap
        modified_overlap = xp.fft.ifft2(fourier_modified_overlap)

        exit_waves = modified_overlap - overlap
        :param ctx: 
        :param tensor_in: Nmodes, K, MY, MX
        :return: wave
        """
        wave_fourier = th.fft.fft2(wave, norm='ortho')
        amplitude_fourier = th.sqrt(th.sum(th.abs(wave_fourier) ** 2, 0))
        af = amplitude_fourier.detach()
        af[af == 0.0] = np.inf
        ctx.save_for_backward(af, wave_fourier, wave)
        return amplitude_fourier

    @staticmethod
    def backward(ctx, amplitudes_target):
        """
        
        :param ctx: 
        :param grad_output: 2, Nmodes, K, MY, MX
        :return: 
        """
        af, wave_fourier, wave = ctx.saved_tensors
        amplitude_modification = amplitudes_target / af
        
        fourier_modified_overlap = amplitude_modification[None] * wave_fourier
        modified_overlap = th.fft.ifft2(fourier_modified_overlap, norm='ortho')
        
        grad_tensor_in = wave - modified_overlap
        return grad_tensor_in

class BinObject(th.autograd.Function):
    '''
    Class that bins the object along the direction of beam propagation (z)
    inputs:
    obj_in: input object
    factor: factor at which the object will be binned
    '''

    @staticmethod
    def forward(ctx, obj_in, factor):
        assert (obj_in.shape[2] % factor) == 0
        assert len(obj_in.shape) == 3
        ctx.factor = factor
        if factor == 1:
            return obj_in
        n_x, n_z, n_y = obj_in.shape
        obj_out = obj_in.reshape(n_x, n_z // factor, factor, n_y).sum(2)
        return obj_out

    @staticmethod
    def backward(ctx, grad_output):
        factor = ctx.factor
        if factor == 1:
            return grad_output, None

        return grad_output.repeat_interleave(factor, dim=1), None
    
class Bin(th.nn.Module):
    def __init__(self, factor):
        self.factor = factor
        super(Bin, self).__init__()
    
    def forward(self, obj_in: th.Tensor) -> th.Tensor:
        return bin_z(obj_in, self.factor)
    
class BatchCrop(th.nn.Module):
    def __init__(self):
        super(BatchCrop, self).__init__()
    
    def forward(self, T: th.Tensor, psi: th.Tensor, r: th.Tensor) -> th.Tensor:
        return split(T, psi, r)
    
class ScaleReversible(th.autograd.Function):
    '''
    Class that bins the object along the direction of beam propagation (z)
    inputs:
    obj_in: input object
    factor: factor at which the object will be binned
    '''
    @staticmethod
    def forward(ctx, wave_in, factor):
        ctx.factor = factor
        if factor == 1:
            return wave_in
        return wave_in * factor

    @staticmethod
    def backward(ctx, grad_output):
        factor = ctx.factor
        if factor == 1:
            return grad_output, None

        return grad_output / factor, None

scale_reversible = ScaleReversible.apply
bin_z = BinObject.apply
complex_abs = ComplexAbs.apply
farfield_amplitude_multimode = FourierExitwaveMeasurementMultiMode.apply
farfield_amplitude_singlemode = FourierExitwaveMeasurementSingleMode.apply
