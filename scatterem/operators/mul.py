# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/operators.mul.ipynb.

# %% auto 0
__all__ = ['regularized_mul', 'regularized_mul_multimode', 'RegularizedComplexMul',
           'RegularizedComplexMulMultiMode']

# %% ../../nbs/operators.mul.ipynb 2
from nbdev.showdoc import *
import torch as th
import torch.nn.functional as F
from ..kernels import split, overlap, overlap_real
from ..core import dtype_complex, dtype_real
import numpy as np

# %% ../../nbs/operators.mul.ipynb 3
from nbdev.showdoc import *
import torch as th
import torch.nn.functional as F
from ..kernels import split, overlap, overlap_real
from ..core import dtype_complex, dtype_real
import numpy as np


class RegularizedComplexMul(th.autograd.Function):
    @staticmethod
    def forward(ctx, S_split: th.Tensor, psi: th.tensor, alpha=th.tensor([0.1])) -> th.Tensor:
        """
        :param S_split: B x K x M1 x M2 tensor
        :param psi: B x M1 x M2

        :return: B x K x M1 x M2
        """
        ctx.save_for_backward(S_split, psi, alpha)

        # print(f'RegularizedComplexMul.forward: psi.shape: {psi.shape}')

        return S_split * psi.unsqueeze(1)

    def backward(ctx, grad_output):
        # psi:        B x M1 x M2
        # S_split:    B x K x M1 x M2 tensor
        # grad_output B x K x M1 x M2

        S_split, psi, alpha = ctx.saved_tensors
        psi = psi.unsqueeze(1)
        alpha = alpha[0]

        grad_S_split = None
        grad_psi = None

        if S_split.requires_grad:
            # B x 1 x M1 x M2
            psi_intensity = th.abs(psi) ** 2
            # 1
            psi_intensity_max = th.max(psi_intensity)
            # B x 1 x M1 x M2
            denom = (1 - alpha) * psi_intensity + alpha * psi_intensity_max

            # print(f'RegularizedComplexMul.backward: grad_output.shape {grad_output.shape}')
            # print(f'RegularizedComplexMul.backward: psi.shape         {psi.shape}')
            # print(f'RegularizedComplexMul.backward: denom.shape       {denom.shape}')

            grad_S_split = grad_output * psi.conj() / denom
            # print(f'RegularizedComplexMul.backward any NaN: {th.any(th.isnan(grad_S_split))}')

        if psi.requires_grad:
            # B x K x M1 x M2
            S_intensity = th.abs(S_split) ** 2
            # B x K x M1 x M2
            denom = S_intensity
            grad_psi = th.mean(grad_output * S_split.conj() / denom, 1)
            # print(f'RegularizedComplexMul.backward any NaN: {th.any(th.isnan(grad_psi))}')

        return grad_S_split, grad_psi

from scatterem.util.base import plotmosaic
class RegularizedComplexMulMultiMode(th.autograd.Function):
    @staticmethod
    def forward(ctx, object_patches: th.Tensor, wave: th.tensor,) -> th.Tensor:
        """
        :param object_patches:              1 x K x M1 x M2
        :param wave:                         Nmodes x K x M1 x M2

        :return: Nmodes x K x M1 x M2
        """
        ctx.save_for_backward(object_patches, wave)
        return object_patches * wave

    def backward(ctx, grad_output):
        # psi:        Nmodes x K x M1 x M2
        # S_split:    1      x K x M1 x M2
        # grad_output Nmodes x K x M1 x M2

        object_patches, wave = ctx.saved_tensors
        grad_object_patches = None
        grad_waves = None
        # print('grad_output.norm 1', th.linalg.norm(grad_output[:, 0].detach()))

        if object_patches.requires_grad:
            # print('object_patches.requires_grad')
            # 1 x K x M1 x M2
            grad_object_patches = th.sum(grad_output * wave.conj(), 0, keepdim=True)

        if wave.requires_grad:
            # print('wave.requires_grad')
            grad_waves = grad_output * object_patches.conj()
            # 1      x K x M1 x M2
            # denom = th.abs(object_patches) ** 2
            # Nmodes      x K x M1 x M2
            # grad_psi = th.sum(grad_output * object_patches.conj(), 1, keepdim=True) / denom
        # print('grad_object_patches.norm 1', th.linalg.norm(grad_object_patches[:, 0].detach()))
        return grad_object_patches, grad_waves, None



regularized_mul = RegularizedComplexMul.apply
regularized_mul_multimode = RegularizedComplexMulMultiMode.apply



