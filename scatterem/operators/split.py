# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/operators.split.ipynb.

# %% auto 0
__all__ = ['split', 'split_volume', 'affine_matrix_3D_ZYX', 'affine_matrix_3D', 'grid_sample_partial', 'ray_transform_partial',
           'SubpixShift', 'SplitAtPositions', 'SplitVolumeAtPositions', 'BatchCropVolume', 'BatchCrop']

# %% ../../nbs/operators.split.ipynb 2
from nbdev.showdoc import *
import torch as th
import torch.nn.functional as F
from ..kernels import split as split_kernel, overlap, overlap_real, overlap_volume, split_volume_kernel, overlap_real_volume
from ..core import dtype_complex, dtype_real
import numpy as np

# %% ../../nbs/operators.split.ipynb 4
def affine_matrix_3D_ZYX(phi, theta, psi, translation):
    c1 = th.cos(phi)
    s1 = th.sin(phi)
    c2 = th.cos(theta)
    s2 = th.sin(theta)
    c3 = th.cos(psi)
    s3 = th.sin(psi)
    line1 = th.stack([c1*c2, c1*s2*s3 - c3*s1, s1*s3 + c1*c3*s2, translation[0]], 1)
    line2 = th.stack([c2*s1, c1*c3 + s1*s2*s3, c3*s1*s2 - c1*s3, th.zeros_like(translation[1])], 1)
    line3 = th.stack([-s2, c2*s3, c2*c3, translation[1]], 1)
    R = th.stack([line1, line2, line3], 1)
    return R

def affine_matrix_3D(phi, theta, psi, translation):
    """Rotation matrix in 2 and 3 dimensions.
    Its rows represent the canonical unit vectors as seen from the
    rotated system while the columns are the rotated unit vectors as
    seen from the canonical system.
    Parameters
    ----------
    phi : `array-like`
        Either 2D counter-clockwise rotation angle (in radians) or first
        Euler angle.
    theta, psi : `array-like`
        Second and third Euler angles in radians. If both are ``None``, a
        2D rotation matrix is computed. Otherwise a 3D rotation is computed,
        where the default ``None`` is equivalent to ``0.0``.
        The rotation is performed in "ZXZ" rotation order, see the
        Wikipedia article `Euler angles`_.
    translation : `array-like`, shape (2, n_angles) 2D translation vector of the projection
    Returns
    -------
    mat : `numpy.ndarray`
        Rotation matrix corresponding to the given angles. The
        returned array has shape ``(ndim, ndim)`` if all angles represent
        single parameters, with ``ndim == 2`` for ``phi`` only and
        ``ndim == 3`` for 2 or 3 Euler angles.
        If any of the angle parameters is an array, the shape of the
        returned array is ``broadcast(phi, theta, psi).shape + (ndim, ndim)``.
    References
    ----------
    .. _Euler angles:
        https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix
    """
    cph = th.cos(phi)
    sph = th.sin(phi)
    cth = th.cos(theta)
    sth = th.sin(theta)
    cps = th.cos(psi)
    sps = th.sin(psi)
    line1 = th.stack([cph * cps - sph * cth * sps, -cph * sps - sph * cth * cps, sph * sth, translation[0]], 1)
    line2 = th.stack([sph * cps + cph * cth * sps, -sph * sps + cph * cth * cps, -cph * sth, translation[1]], 1)
    line3 = th.stack([sth * sps + 0 * cph, sth * cps + 0 * cph, cth + 0 * (cph + cps), th.zeros_like(translation[1])],
                     1)
    R = th.stack([line1, line2, line3], 1)
    return R


def grid_sample_partial(vol, phi_rad, theta_rad, psi_rad, translation, start_end):
    """
    vol         (1,1,NX, NZ, NY)
    phi_rad     (Nangles,)
    theta_rad   (Nangles,)
    psi_rad     (Nangles,)
    translation (2, Nangles,)
    start_end   tuple((ystart,yend),(xstart,xend))

    sino (N_batch, channels, X, Y)
    """
    n_theta = 1
    R = affine_matrix_3D_ZYX(phi_rad, theta_rad, psi_rad, translation)
    out_size = (n_theta, 1, vol.shape[2], vol.shape[3], vol.shape[4])
    grid = F.affine_grid(R, out_size)
    # print(grid.shape)
    grid_partial = grid[:, start_end[0][0]:start_end[0][1], :, start_end[1][0]:start_end[1][1]]
    out = F.grid_sample(vol.expand(n_theta, 1, vol.shape[2], vol.shape[3], vol.shape[4]), grid_partial)#, padding_mode="border")
    # print(out.shape)
    # out is (N_batch, channels, X, Z, Y)
    # out is (1, 1, X, Z, Y)
    # sino = th.sum(out, 3)
    return out[0, 0]


def ray_transform_partial(vol, phi_rad, theta_rad, psi_rad, translation, start_end):
    """
    vol         (1,1,NX, NZ, NY)
    phi_rad     (Nangles,)
    theta_rad   (Nangles,)
    psi_rad     (Nangles,)
    translation (2, Nangles,)
    start_end   tuple((ystart,yend),(xstart,xend))

    sino (N_batch, channels, X, Y)
    """
    n_theta = phi_rad.shape[0]
    R = affine_matrix_3D(phi_rad, theta_rad, psi_rad, translation)
    out_size = (n_theta, 1, vol.shape[2], vol.shape[3], vol.shape[4])
    grid = F.affine_grid(R, out_size)
    grid_partial = grid[:, start_end[0][0]:start_end[0][1], :, start_end[1][0]:start_end[1][1]]
    out = F.grid_sample(vol.expand(n_theta, 1, vol.shape[2], vol.shape[3], vol.shape[4]), grid_partial)
    # print(out.shape)
    # out is (N_batch, channels, X, Z, Y)
    sino = th.sum(out, 3)
    return sino


from numpy.fft import fftfreq, fftshift, fft2, ifft2


class SubpixShift():
    def __init__(self, MY, MX, device):
        qy, qx = np.meshgrid(fftfreq(MY), fftfreq(MX), indexing='ij')
        q = th.stack([th.as_tensor(qy, dtype=th.float32, device=device),
                      th.as_tensor(qx, dtype=th.float32, device=device)])
        self.qqy = q[0][None, None, ...]
        self.qqx = q[1][None, None, ...]

    def __call__(self, w, rs):
        """
        rs: K x 2
        w : probe Nmodes x K x MY x MX
        """
        # ramp is shape 1 x K x MY x MX
        ramp = th.exp(-2j * np.pi * (self.qqy * rs[:, 0][:, None, None] + self.qqx * rs[:, 1][:, None, None]))
        Psi = th.fft.fft2(w)
        # B x K x MY x MX
        # print(ramp.shape,Psi.shape)
        if len(Psi.shape) < 4:
            Psi = Psi.unsqueeze(1)
            Psi = Psi.repeat(1, ramp.shape[1], 1, 1)
        # B x K x MY x MX
        w = th.fft.ifft2(Psi * ramp)
        return w

class SplitAtPositions(th.autograd.Function):
    @staticmethod
    def forward(ctx, obj: th.Tensor, psi: th.Tensor, r: th.Tensor) -> th.Tensor:
        """
        :param S: 1 x NY x NX tensor
        :param psi: Nmodes x K x MY x MX
        :param pos: K x 2 real tensor
        :return: 1 x K x MY x MX complex
        """
        M = th.tensor(psi.shape[-2:])
        out = th.zeros((obj.shape[0], r.shape[0], M[0], M[1]), device=obj.device, dtype=obj.dtype)
        split_kernel(r.data.to(th.int64), th.view_as_real(obj.data), th.view_as_real(out.data))
        ctx.save_for_backward(r, M, th.tensor(obj.shape))
        return out

    @staticmethod
    def backward(ctx, grad_output):
        """
        
        :param ctx: 1 x K x MY x MX complex
        :param grad_output: 
        :return: 
        """
        r, M, S_shape = ctx.saved_tensors
        # 1 x NY x NX
        grad_S = th.zeros(tuple(S_shape), device=grad_output.device, dtype=grad_output.dtype)
        overlap(r.data.to(th.int64), th.view_as_real(grad_output.data), th.view_as_real(grad_S.data))
        return grad_S, None, None
        
class SplitVolumeAtPositions(th.autograd.Function):
    @staticmethod
    def forward(ctx, T: th.Tensor, psi: th.Tensor, r: th.Tensor) -> th.Tensor:
        """
        :param T:                           NX x NZ x NY complex
        :param psi:                         Nmodes x K x MY x MX complex
        :param r:                           K x 2 real
        :param object_patch_normalization:  NZ x K x MY x MX real
        :return:                            NZ x K x M1 x M2 complex
        """
        M = th.tensor(psi.shape[-2:])
        out = th.zeros((T.shape[1], r.shape[0], M[0], M[1]), device=T.device, dtype=T.dtype)
        split_volume_kernel(r.data.to(th.int64), th.view_as_real(T.data), th.view_as_real(out.data))
        ctx.save_for_backward(r, M, th.tensor(T.shape))
        return out

    @staticmethod
    def backward(ctx, grad_output):
        r, M, S_shape = ctx.saved_tensors
        grad_S = th.zeros(tuple(S_shape), device=grad_output.device, dtype=grad_output.dtype)
        overlap_volume(r.data.to(th.int64), th.view_as_real(grad_output.data), th.view_as_real(grad_S.data))
        return grad_S, None, None

split = SplitAtPositions.apply
split_volume = SplitVolumeAtPositions.apply

class BatchCropVolume(th.nn.Module):
    def __int__(self):
        pass
    
    def forward(self, T: th.Tensor, psi: th.Tensor, r: th.Tensor) -> th.Tensor:
        return split_volume(T, psi, r)
    
class BatchCrop(th.nn.Module):
    def __int__(self):
        pass
    
    def forward(self, T: th.Tensor, psi: th.Tensor, r: th.Tensor) -> th.Tensor:
        return split(T, psi, r)
