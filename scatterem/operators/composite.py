# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/operators.composite.ipynb.

# %% auto 0
__all__ = ['complex_2Dobject_forward_model', 'single_slice_patches_model', 'single_slice_ptychography_model',
           'PtychographySingleSlice', 'smatrix_exitwave', 'single_slice_exitwave_multimode_smatrix',
           'exitwave_measurement', 'multislice_exitwave_multimode', 'rotate_partial', 'smatrix_exitwave_multimode',
           'single_slice_ptychography_model_old', 'multislice_ptychography_model', 'ptychographic_tomography_model',
           'multislice_ptychographic_tomography_model']

# %% ../../nbs/operators.composite.ipynb 2
from nbdev.showdoc import *
import torch as th
from .mul import regularized_mul, regularized_mul_multimode, regularized_mul_multimode_smatrix

# %% ../../nbs/operators.composite.ipynb 3
import torch as th
from .split import split
from .basic import bin_z, scale_reversible
import numpy as np

def complex_2Dobject_forward_model(V, probe, pos, angles, translation, bin_factor, start_end, propagator):
    """
    Single slice ptychography model for potential reconstruction.
    :param V: potential, (1, NY, NX), real or complex
    :param pos: probe positions (K, 2) float
    :param angles: Any, not important for this model
    :param translation: Any, not important for this model
    :param bin_factor: Any, not important for this model
    :param start_end: Any, not important for this model
    :param propagator: Any, not important for this model
    :param M: 2D shape of probe
    :return: T_patches, measured amplitudes (1 x K x M1 x M2) complex
    """
    # T = th.exp(1j * V)
    T_patches = split(V, probe, pos)           # out:  1 x K x M1 x M2
    return T_patches#.unsqueeze(0).expand((2,*sh))

def single_slice_patches_model(T_patches, pos, probe, factor):
    """
    Single slice ptychography model for potential reconstruction.
    :param T_patches: potential, (2 x 1 x K x M1 x M2), complex
    :param pos: probe positions (K, 2) float
    :param probe: (Nmodes, 1, MY, MX) complex
    :param factor: Any, not important for this model
    :return: a_model, measured amplitudes (K, MY, MX) float
    """
    phi = regularized_mul_multimode(T_patches, probe)  # out:  Nmodes x K x M1 x M2
    # print('phi.shape', phi.shape)
    a_model = exitwave_measurement(phi)
    a_model = scale_reversible(a_model, factor)
    return a_model

def single_slice_ptychography_model(V, pos, probe, sigma, factor, angles, translation, bin_factor, start_end, propagator):
    """
    Single slice ptychography model for potential reconstruction.
    :param V: potential, (1, NY, NX), real or complex
    :param pos: probe positions (K, 2) float
    :param probe: (Nmodes, 1, MY, MX) complex
    :param sigma: interaction constan, float
    :param angles: Any, not important for this model
    :param translation: Any, not important for this model
    :param bin_factor: Any, not important for this model
    :param start_end: Any, not important for this model
    :param propagator: Any, not important for this model
    :return: a_model, measured amplitudes (K, MY, MX) float
    """
    M = th.tensor(probe.shape[-2:])
    T = th.exp(1j * sigma * V)
    T_patches = split(T, probe, pos)           # out:  1 x K x M1 x M2
    phi = regularized_mul_multimode(T_patches, probe)  # out:  Nmodes x K x M1 x M2
    a_model = exitwave_measurement(phi)
    a_model = scale_reversible(a_model, factor)
    return a_model

class PtychographySingleSlice(th.nn.Module):
    def __init__(self, positions, factor, angles, translation, bin_factor, start_end, object_shape, probe_shape,  *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.r = positions 
        self.fac = factor
        self.angles = angles 
        self.translation = translation 
        self.bin_z = bin_factor
        self.start_end = start_end
        self.object_shape = object_shape
        self.probe_shape = probe_shape
        self.ndim_object = np.prod(object_shape)
        self.ndim_probe = np.prod(probe_shape)
        
    def forward(self, object_and_probe):
        """ 
        
        """
        O = object_and_probe[:self.ndim_object].view(self.object_shape)
        P = object_and_probe[self.ndim_object:].view(self.probe_shape)
        T_patches = split(O, P, self.r)   
        phi = regularized_mul_multimode(T_patches, P)
        a_model = exitwave_measurement(phi)
        a_model = scale_reversible(a_model, factor)
        return a_model.view(-1)




# %% ../../nbs/operators.composite.ipynb 4
from .basic import complex_abs
from .split import grid_sample_partial

def smatrix_exitwave(S_split, psi):
    """

    :param S:   B x K x M1 x M2
    :param psi: Nmodes x B x M1 x M2

    :return:    Nmodes x K x M1 x M2
    """
    Nmodes, _, _, _ = psi.shape
    B, K, M1, M2 = S_split.shape
    result = th.zeros((Nmodes, K, M1, M2), dtype=S_split.dtype, device=S_split.device)
    for i_mode in range(Nmodes):
        # (B x K x M1 x M2) * (B x M1 x M2) -> (Nmodes x K x M1 x M2)
        result[i_mode] = th.sum(regularized_mul(S_split, psi[i_mode]), 0)
    return result


def single_slice_exitwave_multimode_smatrix(T_split, psi):
    """

    :param S:            1 x K x M1 x M2
    :param psi: Nmodes x 1     x M1 x M2

    :return:    Nmodes x K x M1 x M2
    """
    Nmodes, _, _, _ = psi.shape
    # (B     x K x M1 x M2) * (B x Nmodes     x M1 x M2) -> (Nmodes x K x M1 x M2)
    # (B x 1 x K x M1 x M2) * (B x Nmodes x 1 x M1 x M2) -> (Nmodes x K x M1 x M2)
    result = th.sum(regularized_mul_multimode_smatrix(T_split.unsqueeze(1), psi.unsqueeze(2)), 0)
    return result

import scatterem
def exitwave_measurement(phi):
    """

    :param phi: Nmodes x K x M1 x M2
    :return:             K x M1 x M2
    """
    Phi = th.fft.fft2(phi, norm='ortho')
    # Phi = th.fft.fft2(phi[0], norm='ortho') WASP
    # print('Phi.shape', Phi.shape)
    a = th.sqrt(th.sum(complex_abs(Phi) ** 2, 0) + th.finfo(scatterem.core.dtype_real).eps)
    return a


def multislice_exitwave_multimode(T, psi, propagator):
    """

    :param T:            NZ x K x M1 x M2
    :param psi: Nmodes      x K x M1 x M2
    :param propagator: f: (K x M1 x M2, Nmodes      x K x M1 x M2) -> Nmodes      x K x M1 x M2

    :return:    Nmodes      X K x M1 x M2
    """
    Nmodes, _, _, _ = psi.shape
    waves = psi
    for T_i in T:
        waves = regularized_mul_multimode(T_i, waves)
        waves = propagator(waves)
    return waves


def rotate_partial(V, angles, translation, start_end, bin_factor):
    V_rot_partial_real = grid_sample_partial(V.real.unsqueeze(0), angles[[0]], angles[[1]], angles[[2]], translation,
                                             start_end)
    if th.is_complex(V):
        V_rot_partial_imag = grid_sample_partial(V.imag.unsqueeze(0), angles[[0]], angles[[1]], angles[[2]],
                                                 translation,
                                                 start_end)
    V_rot_partial_real = bin_z(V_rot_partial_real, bin_factor)
    if th.is_complex(V):
        V_rot_partial_imag = bin_z(V_rot_partial_imag, bin_factor)

    if th.is_complex(V):
        V_rot_partial = V_rot_partial_real + 1j * V_rot_partial_imag
    else:
        V_rot_partial = V_rot_partial_real
    return V_rot_partial


# %% ../../nbs/operators.composite.ipynb 5
import torch as th
from .split import split
from .basic import bin_z, scale_reversible

def smatrix_exitwave_multimode(S_split, psi):
    """

    :param S:            B x K x M1 x M2
    :param psi: Nmodes x B     x M1 x M2

    :return:    Nmodes x K x M1 x M2
    """
    Nmodes, _, _, _ = psi.shape
    # (B     x K x M1 x M2) * (B x Nmodes     x M1 x M2) -> (Nmodes x K x M1 x M2)
    # (B x 1 x K x M1 x M2) * (B x Nmodes x 1 x M1 x M2) -> (Nmodes x K x M1 x M2)
    result = th.sum(regularized_mul_multimode(S_split.unsqueeze(1), psi.unsqueeze(2)), 0)
    return result

def single_slice_ptychography_model_old(V, pos, probe, sigma, factor, angles, translation, bin_factor, start_end, propagator):
    """
    Single slice ptychography model for potential reconstruction.
    :param V: potential, (1, NY, NX), real or complex
    :param pos: probe positions (K, 2) float
    :param probe: (Nmodes, 1, MY, MX) complex
    :param sigma: interaction constant, float
    :param angles: Any, not important for this model
    :param translation: Any, not important for this model
    :param bin_factor: Any, not important for this model
    :param start_end: Any, not important for this model
    :param propagator: Any, not important for this model
    :return: a_model, measured amplitudes (K, MY, MX) float
    """
    M = th.tensor(probe.shape[-2:])
    T_rot_partial = th.exp(1j * V)
    S_split = split(T_rot_partial, probe, pos)
    phi = smatrix_exitwave_multimode(S_split, probe)
    a_model = exitwave_measurement(phi)
    return a_model

def multislice_ptychography_model(V, pos, probe, sigma, factor, angles, translation, bin_factor, start_end, propagator):
    """
    Calculates Fourier-space intensities
    :param V:               NX x NZ x NY
    :param pos:             K x 2
    :param probe_model:     Nmodes x M1 x M2
    :param propagator:  f: (K x M1 x M2, Nmodes      x K x M1 x M2) -> Nmodes      x K x M1 x M2
    :return: exit waves     K x M1 x M2
    """
    M = th.tensor(probe.shape[-2:])
    T = th.exp(1j * sigma * V)
    # NX x NZ x NY -> NZ x K x M1 x M2
    T_patches = split(T, M, pos)
    # NZ x K x M1 x M2 -> Nmodes x K x M1 x M2
    phi = multislice_exitwave_multimode(T_patches, probe, propagator)
    # K x M1 x M2
    a_model = exitwave_measurement(phi)
    return a_model
#forward_model(V_model, positions, probe_model, angles_device, translation, bin_factor, start_end, propagator)

def ptychographic_tomography_model(V, pos, probe, sigma, factor, angles, translation, bin_factor, start_end, propagator):
    V_rot_partial = rotate_partial(V, angles, translation, start_end, bin_factor)
    V_rot_partial = V_rot_partial.sum(1)  # sum over Z
    V_rot_partial = V_rot_partial.unsqueeze(0)  # B
    # print('V_rot_partial_real.shape', V_rot_partial.shape)
    a_target = single_slice_ptychography_model(V_rot_partial, angles, translation, pos, probe, bin_factor, start_end,
                                               sigma, propagator)
    return a_target

def multislice_ptychographic_tomography_model(V, pos, probe, sigma, factor, angles, translation, bin_factor, start_end, propagator):
    V_rot_partial = rotate_partial(V, angles, translation, start_end, bin_factor)
    # print('V_rot_partial.shape', V_rot_partial.shape)
    # V_rot_partial = V_rot_partial.sum(1)  # Z
    # V_rot_partial = V_rot_partial.unsqueeze(0)  # B
    # print('V_rot_partial_real.shape', V_rot_partial.shape)
    a_target = multislice_ptychography_model(V_rot_partial, angles, translation, pos, probe, bin_factor, start_end,
                                             sigma, propagator)
    return a_target
