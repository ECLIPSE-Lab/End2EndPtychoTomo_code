# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core.__init__.ipynb.

# %% auto 0
__all__ = ['dtype_complex', 'dtype_real', 'HDF5Dataset', 'add_circles', 'Metadata4D', 'ReconstructionOptions', 'SMeta']

# %% ../../nbs/core.__init__.ipynb 2
import torch as th
import h5py
from fastcore.basics import basic_repr

dtype_complex = th.complex64
dtype_real = th.float32

# %% ../../nbs/core.__init__.ipynb 3
from torch.utils import data
import torch

# %% ../../nbs/core.__init__.ipynb 4
from ..util.base import energy_to_wavelength, get_bright_field_size
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle, Circle, Wedge, Ellipse
from matplotlib.axes import Axes
from matplotlib.colors import is_color_like


def add_circles(ax, d):
    """
    adds one or more circles to axis ax using the parameters in dictionary d.
    """
    # handle inputs
    # center
    assert "center" in d.keys()
    center = d["center"]
    if isinstance(center, tuple):
        assert len(center) == 2
        center = [center]
    assert isinstance(center, list)
    N = len(center)
    assert all([isinstance(x, tuple) for x in center])
    assert all([len(x) == 2 for x in center])
    # radius
    assert "R" in d.keys()
    R = d["R"]
    assert isinstance(R, list)
    assert len(R) == N
    # color
    color = d["color"] if "color" in d.keys() else "r"
    if isinstance(color, list):
        assert len(color) == N
    else:
        color = [color for i in range(N)]
    # fill
    fill = d["fill"] if "fill" in d.keys() else False
    if isinstance(fill, bool):
        fill = [fill for i in range(N)]
    else:
        assert isinstance(fill, list)
        assert len(fill) == N
        assert all([isinstance(f, bool) for f in fill])
    # alpha
    alpha = d["alpha"] if "alpha" in d.keys() else 1
    if isinstance(alpha, (float, int, np.float64)):
        alpha = [alpha for i in range(N)]
    else:
        assert isinstance(alpha, list)
        assert len(alpha) == N
        assert all([isinstance(a, (float, int, np.float64)) for a in alpha])
    # linewidth
    linewidth = d["linewidth"] if "linewidth" in d.keys() else 2
    if isinstance(linewidth, (float, int, np.float64)):
        linewidth = [linewidth for i in range(N)]
    else:
        assert isinstance(linewidth, list)
        assert len(linewidth) == N
        assert all([isinstance(lw, (float, int, np.float64)) for lw in linewidth])
    # additional parameters
    kws = [
        k
        for k in d.keys()
        if k not in ("center", "R", "color", "fill", "alpha", "linewidth")
    ]
    kwargs = dict()
    for k in kws:
        kwargs[k] = d[k]

    # add the circles
    for i in range(N):
        cent, r, col, f, a, lw = (
            center[i],
            R[i],
            color[i],
            fill[i],
            alpha[i],
            linewidth[i],
        )
        circ = Circle(
            (cent[1], cent[0]), r, color=col, fill=f, alpha=a, linewidth=lw, **kwargs
        )
        ax.add_patch(circ)

    return


class Metadata4D:
    __repr__ = basic_repr(
        ['sampling_realspace_angstrom', 'dk', 'alpha_mrad', 'rotation_deg', 'energy_keV', 'wavelength_angstrom',
         'aberrations'])

    def __init__(self, alpha_mrad, energy_keV=None, sampling_realspace_angstrom=[1, 1]):
        if type(sampling_realspace_angstrom) is float or len(sampling_realspace_angstrom) < 2:
            sampling_realspace_angstrom = np.array([sampling_realspace_angstrom, sampling_realspace_angstrom])
        self.sampling_realspace_angstrom = sampling_realspace_angstrom
        self.dr = sampling_realspace_angstrom
        self.dk = None
        self.alpha_mrad = alpha_mrad
        self.rotation_deg = None
        self.energy_keV = energy_keV
        self.wavelength_angstrom = energy_to_wavelength(energy_keV*1e3)
        self.aberrations = np.zeros((12,))

    def determine_dk_from_bright_field_disk_(self, data: th.Tensor, thresh_lower=0.01, thresh_upper=0.99,
                                             verbose=False):
        if len(data.shape) < 4:
            raise RuntimeError('len(data.shape)')
        mean_dp = np.mean(data, (0, 1))
        r, x0, y0 = get_bright_field_size(mean_dp, thresh_lower=thresh_lower, thresh_upper=thresh_upper, N=100)
        dalpha = self.alpha_mrad * 1e-3 / r
        dk = dalpha / self.wavelength_angstrom
        self.dk = np.array([dk, dk])
        if verbose:
            print(f'BF radius: {r:2.2f}')
            print(f'BF y,x: {y0:2.2f},{x0:2.2f}')
            print(f'dk [A^(-1)]: {dk}')
            color = "r"
            fill = True
            alpha = 0.3
            linewidth = 2
            fig, ax = plt.subplots()
            d = {
                "center": (x0, y0),
                "R": [r],
                "color": color,
                "fill": fill,
                "alpha": alpha,
                "linewidth": linewidth,
            }
            add_circles(ax, d)
            ax.imshow(mean_dp)
            plt.show()

    def to_h5(self, file_path, key):
        with h5py.File(file_path, 'a') as f:
            g = f.create_group(key)
            g.create_dataset('scan_step', data=self.sampling_realspace_angstrom)
            g.create_dataset('dk', data=self.dk)
            g.create_dataset('alpha_mrad', data=self.alpha_mrad)
            g.create_dataset('rotation_deg', data=self.rotation_deg)
            g.create_dataset('energy_keV', data=self.energy_keV)
            g.create_dataset('wavelength', data=self.wavelength_angstrom)
            g.create_dataset('aberrations', data=self.aberrations)

    @staticmethod
    def from_h5(file_path, key):
        res = Metadata4D()
        with h5py.File(file_path, 'r') as f:
            g = f[key]
            res.scan_step = g['scan_step'][...]
            res.dk = g['dk'][...]
            res.alpha_mrad = g['alpha_mrad'][()]
            res.rotation_deg = g['rotation_deg'][()]
            res.E_ev = g['energy_keV'][()]
            res.wavelength_angstrom = g['wavelength_angstrom'][()]
            res.aberrations = g['aberrations'][...]
        return res


# %% ../../nbs/core.__init__.ipynb 5
class ReconstructionOptions:
    def __init__(self):
        pass

# %% ../../nbs/core.__init__.ipynb 6
from ..util.base import fourier_coordinates_2D
import torch as th
import numpy as np
from numpy.fft import fftshift


class SMeta:
    def __init__(self, take_beams, dx, S_shape, MY, MX, device):
        self.f = S_shape[1:] / np.array([MY, MX])
        self.S_shape = S_shape
        self.q = th.as_tensor(fourier_coordinates_2D(S_shape[1:], dx.numpy(), centered=False), device=device)
        self.qf = th.as_tensor(fourier_coordinates_2D([MY, MX], dx.numpy(), centered=False), device=device)
        self.q2 = th.norm(self.q, dim=0) ** 2
        self.qf2 = th.norm(self.qf, dim=0) ** 2
        self.q_coords = th.from_numpy(
            fftshift(np.array(np.mgrid[-MY // 2:MY // 2, -MX // 2:MX // 2]), (1, 2))).to(device)
        self.r_indices = th.from_numpy(np.mgrid[:MY, :MX]).to(device)
        self.take_beams = take_beams.to(device)

        B = th.sum(take_beams).item()
        self.beam_numbers = th.ones_like(take_beams, dtype=th.long, device=device) * -1
        self.beam_numbers[take_beams] = th.arange(0, B, device=device)
        self.q_b = th.stack([self.qf[0, take_beams], self.qf[1, take_beams]]).T
        self.q_b_coords = th.from_numpy(np.mgrid[:MY, :MX]).to(device)
        self.q_dft = th.from_numpy(fourier_coordinates_2D([MY, MX], [1, 1], centered=False)).to(device)

        #S_shape          array (3,)        
        #q              (NY, NX) x
        #qf             (MY, MX) x
        #q2             (NY, NX) x
        #q2f            (MY, MX) x
        #f              (2,)
        #q_coords       (MY, MX)
        #r_indices      (NY, NX)
        #take_beams     (MY, MX)
        #beam_numbers   (MY, MX)
        #q_b            (B, 2)
        #q_b_coords     (B, 2)
