# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/kernels.ipynb.

# %% auto 0
__all__ = ['overlap', 'overlap_volume', 'update_object_2D', 'overlap_real_subpix', 'overlap_intensity',
           'overlap_intensity_no_subpix', 'overlap_real', 'overlap_real_volume', 'split', 'split_volume_kernel',
           'amplitude_loss_function']

# %% ../nbs/kernels.ipynb 1
from nbdev.showdoc import *
import taichi as ti
import numpy as np
import torch as th
import matplotlib.pyplot as plt

# %% ../nbs/kernels.ipynb 2
@ti.kernel
def overlap(r: ti.types.ndarray(ndim=2),
            z: ti.types.ndarray(ndim=5),
            out: ti.types.ndarray(ndim=4)):
    """

    :param r:   K x 2
    :param z:   1 x K x MY x MX x 2
    :param out: 1 x NY x NX x 2
    :return:
    """

    ti.loop_config(parallelize=8, block_dim=256)
    for b, k, my, mx, i in z:
        y = r[k, 0]
        x = r[k, 1]
        ti.atomic_add(out[0, y + my, x + mx, i], z[b, k, my, mx, i])


@ti.kernel
def overlap_volume(r: ti.types.ndarray(ndim=2),
                   grad_patches: ti.types.ndarray(ndim=5),
                   out: ti.types.ndarray(ndim=4)):
    """

    :param r:   K x 2
    :param grad_patches:   NZ x K x MY x MX x 2
    :param out: NY x NZ x NX x 2
    :return:
    """

    ti.loop_config(parallelize=8, block_dim=256)
    for nz, k, my, mx, i in grad_patches:
        y = r[k, 0]
        x = r[k, 1]
        ti.atomic_add(out[y + my, nz, x + mx, i], grad_patches[nz, k, my, mx, i])


# def update_object(object, pos, object_crop_gradient):
@ti.kernel
def update_object_2D(object: ti.types.ndarray(ndim=3),
                     r: ti.types.ndarray(ndim=2),
                     object_crop_gradient: ti.types.ndarray(ndim=3)):
    """
    object, pos, object_crop_gradient
    :param object: B x NY x NX x 2
    :param r:   K x 2
    :param object_crop_gradient: B x K x MY x MX x 2
    :return:
    """

    ti.loop_config(parallelize=8, block_dim=256)
    for b, k, my, mx, i in object_crop_gradient:
        y = r[k, 0]
        x = r[k, 1]
        ti.atomic_add(object[b, y + my, x + mx, i], object_crop_gradient[b, k, my, mx, i])

# %% ../nbs/kernels.ipynb 3
import taichi.math as tm


@ti.kernel
def overlap_real_subpix(r: ti.types.ndarray(ndim=2),
                        z: ti.types.ndarray(ndim=5),
                        out: ti.types.ndarray(ndim=3)):
    """

    :param r:   K x 2
    :param z:   B x K x MY x MX x 2
    :param out: B x NY x NX
    :return:
    """

    ti.loop_config(parallelize=8, block_dim=256)
    B, qqq, MY, MX, ww = z.shape
    K = r.shape[0]
    print(B, qqq, MY, MX, ww)
    print(K)
    for b, k, my, mx in ti.ndrange(B, K, MY, MX):
        # print(k)
        y = r[k, 0]
        x = r[k, 1]
        absz = tm.sqrt(z[b, k, my, mx, 0] ** 2 + z[b, k, my, mx, 1] ** 2)
        ti.atomic_add(out[b, y + my, x + mx], absz)

@ti.kernel
def overlap_intensity(r: ti.types.ndarray(ndim=2),
                        probe: ti.types.ndarray(ndim=5),
                        out: ti.types.ndarray(ndim=2)):
    """

    :param r:                   K x 2
    :param probe_normalization: Nmodes x K x MY x MX x 2
    :param out:                 1 x NY x NX
    :return:
    """
    ti.loop_config(parallelize=8, block_dim=256)
    Nmodes, K, MY, MX, ww = probe.shape
    for n, k, my, mx in ti.ndrange(Nmodes, K, MY, MX):
        y = r[k, 0]
        x = r[k, 1]
        mode_intensity = probe[n, k, my, mx, 0] ** 2 + probe[n, k, my, mx, 1] ** 2
        ti.atomic_add(out[y + my, x + mx], mode_intensity)
        
@ti.kernel
def overlap_intensity_no_subpix(r: ti.types.ndarray(ndim=2),
                        probe_normalization: ti.types.ndarray(ndim=5),
                        out: ti.types.ndarray(ndim=3)):
    """

    :param r:                   K x 2
    :param probe_normalization: MY x MX
    :param out:                 1 x NY x NX
    :return:
    """
    K = r.shape[0]
    MY, MX = probe_normalization.shape
    ti.loop_config(parallelize=8, block_dim=256)
    for k, my, mx in ti.ndrange( K, MY, MX):
        y = r[k, 0]
        x = r[k, 1]
        ti.atomic_add(out[0, y + my, x + mx], probe_normalization[my, mx])
        
# @ti.kernel
# def overlap_intensity_no_subpix(r: ti.types.ndarray(ndim=2), z: ti.types.ndarray(ndim=5), out: ti.types.ndarray(ndim=3)):
#     """
# 
#     :param r:   K x 2
#     :param z:   Nmodes x 1 x MY x MX x 2
#     :param out: 1 x NY x NX
#     :return:
#     """
# 
#     ti.loop_config(parallelize=8, block_dim=256)
#     Nmodes, _, MY, MX, ww = z.shape
#     K = r.shape[0]
#     for nm, k, my, mx in ti.ndrange(Nmodes, K, MY, MX):
#         y = r[k, 0]
#         x = r[k, 1]
#         absz = tm.sqrt(z[nm, 0, my, mx, 0] ** 2 + z[nm, k, my, mx, 1] ** 2)
#         ti.atomic_add(out[0, y + my, x + mx], absz)


@ti.kernel
def overlap_real(r: ti.types.ndarray(ndim=2),
                 z: ti.types.ndarray(ndim=5),
                 out: ti.types.ndarray(ndim=3)):
    """

    :param r:   K x 2
    :param z:   B x MY x MX x 2
    :param out: B x NY x NX
    :return:
    """

    ti.loop_config(parallelize=8, block_dim=256)
    B, MY, MX, ww = z.shape
    K = r.shape[0]
    for b, k, my, mx in ti.ndrange(B, K, MY, MX):
        y = r[k, 0]
        x = r[k, 1]
        absz = tm.sqrt(z[b, my, mx, 0] ** 2 + z[b, my, mx, 1] ** 2)
        ti.atomic_add(out[b, y + my, x + mx], absz)


@ti.kernel
def overlap_real_volume(r: ti.types.ndarray(ndim=2),
                        probe_normalization: ti.types.ndarray(ndim=5),
                        out: ti.types.ndarray(ndim=3)):
    """

    :param r:                   K x 2
    :param probe_normalization: NZ x K x MY x MX
    :param out:                 NY x NZ x NX
    :return:
    """
    ti.loop_config(parallelize=8, block_dim=256)
    for k, my, mx in probe_normalization:
        y = r[k, 0]
        x = r[k, 1]
        ti.atomic_add(out[y + my, x + mx], probe_normalization[k, my, mx])


# %% ../nbs/kernels.ipynb 5
@ti.kernel
def split(r: ti.types.ndarray(ndim=2),
          t: ti.types.ndarray(ndim=4),
          out: ti.types.ndarray(ndim=5)):
    """
    
    :param r:   K x 2
    :param t:   B x NY x NX x 2
    :param out: B x K x MY x MX x 2
    :return:
    """

    ti.loop_config(parallelize=8, block_dim=256)
    for b, k, my, mx, i in out:
        y = r[k, 0]
        x = r[k, 1]
        out[b, k, my, mx, i] = t[b, y + my, x + mx, i]


@ti.kernel
def split_volume_kernel(r: ti.types.ndarray(ndim=2),
                        object: ti.types.ndarray(ndim=4),
                        out: ti.types.ndarray(ndim=5)):
    """
    
    :param r:   K x 2
    :param t:   NY x NZ x NX x 2
    :param out: NZ x K x MY x MX x 2
    :return:
    """

    ti.loop_config(parallelize=8, block_dim=256)
    for nz, k, my, mx, i in out:
        y = r[k, 0]
        x = r[k, 1]
        out[nz, k, my, mx, i] = object[y + my, nz, x + mx, i]

# %% ../nbs/kernels.ipynb 6
import taichi


@ti.kernel
def amplitude_loss_function(a_model: ti.types.ndarray(ndim=3),
                            a_target: ti.types.ndarray(ndim=3),
                            loss: ti.types.ndarray(ndim=1), ):
    """

    :param z:           K x My x Mx x 2
    :param z_hat:       K x My x Mx x 2
    :param a:           K x My x Mx
    :param beta:        1
    :param a_strides:   (4,)
    :return:
    """
    ti.loop_config(parallelize=8, block_dim=256)
    for k, my, mx in a_model:
        # grad[k, my, mx] = a_target[k, my, mx]  # 1 - (a_target[k, my, mx] / (a_model[k, my, mx]+1e-6))
        ti.atomic_add(loss[k], taichi.abs(a_model[k, my, mx] - a_target[k, my, mx]) ** 2)



# %% ../nbs/kernels.ipynb 7
#| export

